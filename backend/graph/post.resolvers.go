package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/wilbertcoandssss/training-preweb/graph/model"
)

// InsertPost is the resolver for the insertPost field.
func (r *mutationResolver) InsertPost(ctx context.Context, inputPost model.NewPostInput) (*model.Post, error) {
	post := &model.Post{
		ID:          uuid.NewString(),
		ContentText: inputPost.ContentText,
		AuthorID:    inputPost.AuthorID,
		PostDate:    inputPost.PostDate,
		PostPrivacy: inputPost.PostPrivacy,
	}

	return post, r.DB.Save(&post).Error
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, postID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeletePost - deletePost"))
}

// DeleteGroupPost is the resolver for the deleteGroupPost field.
func (r *mutationResolver) DeleteGroupPost(ctx context.Context, postID string) (bool, error) {
	var groupPost *model.GroupPost

	if err := r.DB.First(&groupPost, "id = ?", postID).Delete(&groupPost).Error; err != nil {
		return false, err
	}

	var comment *model.Comment

	if err := r.DB.Where("post_id = ?", postID).Find(&comment).Error; err != nil {
		return false, err
	}

	// Delete Replies
	if err := r.DB.Where("comment_id = ?", comment.ID).Delete(&model.Replies{}).Error; err != nil {
		return false, err
	}

	// Delete Commet
	if err := r.DB.Where("post_id = ?", postID).Delete(&model.Comment{}).Error; err != nil {
		return false, err
	}

	return true, nil
}

// GetAllPost is the resolver for the getAllPost field.
func (r *queryResolver) GetAllPost(ctx context.Context, limit *int, offset *int) ([]*model.FetchPost, error) {
	var posts []*model.Post

	actualOffset := 0
	if offset != nil {
		actualOffset = *offset
	}

	actualLimit := 10 // You can adjust this default value as needed
	if limit != nil {
		actualLimit = *limit
	}

	if err := r.DB.Limit(actualLimit).Offset(actualOffset).Find(&posts).Error; err != nil {
		return nil, err
	}

	var fetchPosts []*model.FetchPost

	// Iterate through each Post and create a corresponding FetchPost
	for _, post := range posts {
		fetchPost := &model.FetchPost{
			ID:           post.ID,
			ContentText:  post.ContentText,
			AuthorID:     post.AuthorID,
			PostDate:     post.PostDate,
			PostPrivacy:  post.PostPrivacy,
			AuthorData:   nil, // Initialize AuthorData as nil
			LikedCount:   0,   // Initialize LikeCount
			MediaURL:     nil,
			CommentCount: 0,
			TaggedUser:   nil,
		}
		// Retrieve user data based on AuthorID from the database
		var user model.User

		if err := r.DB.Where("id = ?", post.AuthorID).First(&user).Error; err != nil {
			return nil, err
		}

		fetchPost.AuthorData = &user // Set AuthorData with user data

		// Count likes for the current post
		var likeCount int64
		if err := r.DB.Model(&model.Like{}).Where("post_id = ?", post.ID).Count(&likeCount).Error; err != nil {
			return nil, err
		}

		fetchPost.LikedCount = int(likeCount)

		// Count likes for the current post
		var commentCount int64
		if err := r.DB.Model(&model.Comment{}).Where("post_id = ?", post.ID).Count(&commentCount).Error; err != nil {
			return nil, err
		}

		fetchPost.CommentCount = int(commentCount)

		// Tagged User
		var taggedUser []*model.TaggedUser

		if err := r.DB.Where("post_id = ?", post.ID).Find(&taggedUser).Error; err != nil {
			return nil, err
		}

		var users []*model.User

		for _, tag := range taggedUser {
			var u *model.User

			if err := r.DB.Where("id = ?", tag.UserID).First(&u).Error; err != nil {
				return nil, err
			}

			users = append(users, u)
		}

		fetchPost.TaggedUser = users
		// Media
		var mediaURLs []string
		var mediaList []*model.Media
		if err := r.DB.Where("post_id = ?", post.ID).Find(&mediaList).Error; err != nil {
			return nil, err
		}
		for _, media := range mediaList {
			mediaURLs = append(mediaURLs, media.MediaURL)
		}
		fetchPost.MediaURL = mediaURLs

		fetchPosts = append(fetchPosts, fetchPost)
	}

	return fetchPosts, nil
}

// GetAllPostWithoutLimit is the resolver for the getAllPostWithoutLimit field.
func (r *queryResolver) GetAllPostWithoutLimit(ctx context.Context, limit *int, offset *int) ([]*model.FetchPost, error) {
	var posts []*model.Post

	actualOffset := 0
	if offset != nil {
		actualOffset = *offset
	}

	actualLimit := 10 // You can adjust this default value as needed
	if limit != nil {
		actualLimit = *limit
	}

	if err := r.DB.Limit(actualLimit).Offset(actualOffset).Find(&posts).Error; err != nil {
		return nil, err
	}

	var fetchPosts []*model.FetchPost

	// Iterate through each Post and create a corresponding FetchPost
	for _, post := range posts {
		fetchPost := &model.FetchPost{
			ID:          post.ID,
			ContentText: post.ContentText,
			AuthorID:    post.AuthorID,
			PostDate:    post.PostDate,
			PostPrivacy: post.PostPrivacy,
			AuthorData:  nil, // Initialize AuthorData as nil
			LikedCount:  0,   // Initialize LikeCount
			MediaURL:    nil,
		}
		// Retrieve user data based on AuthorID from the database
		var user model.User

		if err := r.DB.Where("id = ?", post.AuthorID).First(&user).Error; err != nil {
			return nil, err
		}

		fetchPost.AuthorData = &user // Set AuthorData with user data

		// Count likes for the current post
		var likeCount int64
		if err := r.DB.Model(&model.Like{}).Where("post_id = ?", post.ID).Count(&likeCount).Error; err != nil {
			return nil, err
		}

		fetchPost.LikedCount = int(likeCount)

		// Media
		var mediaURLs []string
		var mediaList []*model.Media
		if err := r.DB.Where("post_id = ?", post.ID).Find(&mediaList).Error; err != nil {
			return nil, err
		}
		for _, media := range mediaList {
			mediaURLs = append(mediaURLs, media.MediaURL)
		}
		fetchPost.MediaURL = mediaURLs

		fetchPosts = append(fetchPosts, fetchPost)
	}

	return fetchPosts, nil
}

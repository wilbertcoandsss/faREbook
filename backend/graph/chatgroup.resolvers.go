package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/wilbertcoandssss/training-preweb/graph/model"
)

// CreateGroupChat is the resolver for the createGroupChat field.
func (r *mutationResolver) CreateGroupChat(ctx context.Context, groupID string) (bool, error) {
	newGroupChat := &model.ChatGroupHeader{
		ID:        uuid.NewString(),
		GroupID:   groupID,
		CreatedAt: time.Now().Format("2006-01-02 15:04:05"),
	}

	return true, r.DB.Save(&newGroupChat).Error
}

// CreateGroupMessage is the resolver for the createGroupMessage field.
func (r *mutationResolver) CreateGroupMessage(ctx context.Context, inputChatDetail model.NewChatGroupDetail) (bool, error) {
	if inputChatDetail.Type == "Text" {
		newMsg := &model.ChatGroupDetails{
			ID:           uuid.NewString(),
			ChatHeaderID: inputChatDetail.ChatHeaderID,
			SenderID:     inputChatDetail.SenderID,
			ChatText:     inputChatDetail.ChatText,
			CreatedAt:    time.Now().Format("2006-01-02 15:04:05"),
			Type:         "Text",
			MediaURL:     "",
		}

		for _, conn := range r.Conns {
			err := conn.WriteJSON(&newMsg)
			if err != nil {
				fmt.Println(err)
			}
		}

		return true, r.DB.Save(&newMsg).Error
	} else {
		newMsg := &model.ChatGroupDetails{
			ID:           uuid.NewString(),
			ChatHeaderID: inputChatDetail.ChatHeaderID,
			SenderID:     inputChatDetail.SenderID,
			ChatText:     inputChatDetail.ChatText,
			CreatedAt:    time.Now().Format("2006-01-02 15:	"),
			Type:         "Media",
			MediaURL:     inputChatDetail.MediaURL,
		}

		for _, conn := range r.Conns {
			err := conn.WriteJSON(&newMsg)
			if err != nil {
				fmt.Println(err)
			}
		}

		return true, r.DB.Save(&newMsg).Error
	}
}

// GetGroupChatHeader is the resolver for the getGroupChatHeader field.
func (r *queryResolver) GetGroupChatHeader(ctx context.Context, userID string) ([]*model.FetchGroupChat, error) {
	panic(fmt.Errorf("not implemented: GetGroupChatHeader - getGroupChatHeader"))
}

// GetAllGroupConversation is the resolver for the getAllGroupConversation field.
func (r *queryResolver) GetAllGroupConversation(ctx context.Context, groupID string) ([]*model.FetchGroupChat, error) {
	var convos []*model.ChatGroupHeader

	if err := r.DB.Where("group_id = ?", groupID).Find(&convos).Error; err != nil {
		return nil, err
	}

	var fetchConvos []*model.FetchGroupChat

	for _, convo := range convos {
		fetchConvo := &model.FetchGroupChat{
			ChatHeaderID:           convo.ID,
			ChatHeaderInformation:  nil,
			ChatDetailsInformation: nil,
			SenderData:             nil,
		}

		var chatHeaderInfo model.ChatGroupHeader

		if err := r.DB.Where("id = ?", convo.ID).First(&chatHeaderInfo).Error; err != nil {
			return nil, err
		}

		fetchConvo.ChatHeaderInformation = &chatHeaderInfo

		var chatDetails []*model.ChatGroupDetails

		if err := r.DB.Where("chat_header_id = ?", convo.ID).Find(&chatDetails).Error; err != nil {
			return nil, err
		}

		fetchConvo.ChatDetailsInformation = chatDetails

		var users []*model.User

		for _, user := range chatDetails {
			var user1 *model.User

			if err := r.DB.Where("id = ?", user.SenderID).First(&user1).Error; err != nil {
				return nil, err
			}

			users = append(users, user1)
		}

		fetchConvo.SenderData = users

		fetchConvos = append(fetchConvos, fetchConvo)
	}

	return fetchConvos, nil
}

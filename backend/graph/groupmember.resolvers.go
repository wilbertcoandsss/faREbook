package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"

	"github.com/wilbertcoandssss/training-preweb/graph/model"
)

// InsertGroupMember is the resolver for the insertGroupMember field.
func (r *mutationResolver) InsertGroupMember(ctx context.Context, newGroupMember model.NewGroupMember) (bool, error) {
	if newGroupMember.Role == "Admin" {
		newMember := &model.GroupMember{
			UserID:  newGroupMember.UserID,
			GroupID: newGroupMember.GroupID,
			Role:    newGroupMember.Role,
			Status:  "Approved",
		}
		return true, r.DB.Create(&newMember).Error
	} else {
		newMember := &model.GroupMember{
			UserID:  newGroupMember.UserID,
			GroupID: newGroupMember.GroupID,
			Role:    newGroupMember.Role,
			Status:  "Pending",
		}
		return true, r.DB.Create(&newMember).Error
	}
}

// AcceptInvitation is the resolver for the acceptInvitation field.
func (r *mutationResolver) AcceptInvitation(ctx context.Context, userID string, groupID string, status string) (bool, error) {
	query := `
	UPDATE group_members
	SET status = 'Approved'
	WHERE user_id = ? AND group_id = ?
	`

	result := r.DB.Exec(query, userID, groupID)

	if result.Error != nil {
		return false, result.Error
	}

	return true, nil
}

// DeclineInvitation is the resolver for the declineInvitation field.
func (r *mutationResolver) DeclineInvitation(ctx context.Context, userID string, groupID string) (bool, error) {
	var member model.GroupMember

	if err := r.DB.
		Where("user_id = ? AND group_id = ? AND status IN (?)", userID, groupID, []string{"Pending", "Requested", "Approved"}).
		First(&member).
		Delete(&member).
		Error; err != nil {
		return false, err
	}

	return true, nil
}

// LeaveGroup is the resolver for the leaveGroup field.
func (r *mutationResolver) LeaveGroup(ctx context.Context, userID string, groupID string) (bool, error) {
	var member *model.GroupMember

	if err := r.DB.First(&member, "user_id = ? AND group_id = ?", userID, groupID).Delete(&member).Error; err != nil {
		return false, err
	}

	return true, nil
}

// SendRequest is the resolver for the sendRequest field.
func (r *mutationResolver) SendRequest(ctx context.Context, userID string, groupID string) (bool, error) {
	newMember := &model.GroupMember{
		UserID:  userID,
		GroupID: groupID,
		Role:    "Member",
		Status:  "Requested",
	}

	return true, r.DB.Create(&newMember).Error
}

// PromoteMember is the resolver for the promoteMember field.
func (r *mutationResolver) PromoteMember(ctx context.Context, userID string, groupID string) (bool, error) {
	query := `
	UPDATE group_members
	SET role = 'Admin'
	WHERE user_id = ? AND group_id = ?
	`

	result := r.DB.Exec(query, userID, groupID)

	if result.Error != nil {
		return false, result.Error
	}

	return true, nil
}

// ExitGroupAdmin is the resolver for the exitGroupAdmin field.
func (r *mutationResolver) ExitGroupAdmin(ctx context.Context, userID string, groupID string) (bool, error) {
	groupInfo, err := r.Query().GetGroupInfo(ctx, groupID) // Implement this function to retrieve group info

	if err != nil {
		return false, err
	}

	isAdmin := false
	isAdminCount := 0
	isMemberCount := 0

	// Check if the user is an admin and count the total number of admins
	for _, member := range groupInfo.GroupMember {
		isMemberCount++
		fmt.Println(member.UserData.Firstname)
		fmt.Println(groupInfo.GroupName)
		if member.GroupMember.UserID == userID && member.GroupMember.Role == "Admin" {
			isAdmin = true
		}
		if member.GroupMember.Role == "Admin" {
			isAdminCount++
		}
	}

	fmt.Println(isAdminCount, isMemberCount)

	if isAdminCount == 1 && isAdmin {
		// Check if there lonely admin no member
		if isMemberCount == 1 {
			fmt.Println("UDAH DEH WKWK DELETE AJA GRUPNYA")
			deleteGroup, err := r.Mutation().DeleteGroup(ctx, groupID) // Implement this function to delete the group
			if deleteGroup == false {
				return false, err
			}
			return true, err
		} else {
			// Return minta yang lain buat jadi admin dulu
			fmt.Println("MINTA YG LAIN BUAT JD ADMIN")
			return false, err
		}
	} else if isAdminCount > 1 {
		leaveGroup, err := r.Mutation().LeaveGroup(ctx, userID, groupID)
		fmt.Println("ADA ADMIN LAIN, aman leave aja", isAdminCount)
		if leaveGroup == false {
			return false, err
		}
		return true, err
	}
	return true, nil
}

// CheckRole is the resolver for the checkRole field.
func (r *queryResolver) CheckRole(ctx context.Context, groupID string, userID string) (string, error) {
	var member *model.GroupMember

	if err := r.DB.Where("group_id = ? AND user_id = ?", groupID, userID).Find(&member).Error; err != nil {
		return "nil", err
	}

	return member.Role, nil
}

// CheckInvitation is the resolver for the checkInvitation field.
func (r *queryResolver) CheckInvitation(ctx context.Context, userID string) ([]*model.Group, error) {
	var member []*model.GroupMember

	if err := r.DB.Where("user_id = ? AND status = ?", userID, "Pending").Find(&member).Error; err != nil {
		return nil, err
	}

	var groups []*model.Group

	for _, member := range member {
		var group *model.Group

		if err := r.DB.Where("id = ?", member.GroupID).First(&group).Error; err != nil {
			return nil, err
		}

		groups = append(groups, group)
	}

	return groups, nil
}

// CheckRequest is the resolver for the checkRequest field.
func (r *queryResolver) CheckRequest(ctx context.Context, groupID string) ([]*model.User, error) {
	var member []*model.GroupMember

	if err := r.DB.Where("group_id = ? AND status = ?", groupID, "Requested").Find(&member).Error; err != nil {
		return nil, err
	}

	var user []*model.User

	for _, member := range member {
		var u *model.User

		if err := r.DB.Where("id = ?", member.UserID).First(&u).Error; err != nil {
			return nil, err
		}

		user = append(user, u)
	}

	return user, nil
}

// GetGroupMember is the resolver for the getGroupMember field.
func (r *queryResolver) GetGroupMember(ctx context.Context, groupID string) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: GetGroupMember - getGroupMember"))
}

package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"path"
	"time"

	"github.com/google/uuid"
	"github.com/wilbertcoandssss/training-preweb/graph/model"
)

// CreateGroupFile is the resolver for the createGroupFile field.
func (r *mutationResolver) CreateGroupFile(ctx context.Context, newFile model.NewFiles) (*model.GroupFiles, error) {
	// Check if the file name already exists in the database
	existingFile, err := r.Query().GetFileByName(ctx, newFile.FileName)

	if existingFile == nil && err != nil {
		newGroupFile := &model.GroupFiles{
			ID:           uuid.NewString(),
			GroupID:      newFile.GroupID,
			OwnerID:      newFile.OwnerID,
			FileName:     newFile.FileName,
			UploadedDate: time.Now().Format("2006-01-02 15:04:05"),
			MediaURL:     newFile.MediaURL,
			FileType:     newFile.FileType,
		}

		return newGroupFile, r.DB.Save(&newGroupFile).Error
	} else {
		count := 1
		fmt.Println("BARU")
		uniqueFileName := newFile.FileName
		ext := path.Ext(newFile.FileName)
		uniqueFileName = fmt.Sprintf("%s (%d)%s", newFile.FileName[:len(newFile.FileName)-len(ext)], count, ext)

		existingNewFile, err := r.Query().GetFileByName(ctx, uniqueFileName)

		for existingNewFile != nil && err == nil {
			count++
			uniqueFileName = fmt.Sprintf("%s (%d)%s", newFile.FileName[:len(newFile.FileName)-len(ext)], count, ext)
			existingNewFile, err = r.Query().GetFileByName(ctx, uniqueFileName)
		}

		fmt.Println(uniqueFileName)
		newGroupFile := &model.GroupFiles{
			ID:           uuid.NewString(),
			GroupID:      newFile.GroupID,
			OwnerID:      newFile.OwnerID,
			FileName:     uniqueFileName,
			UploadedDate: time.Now().Format("2006-01-02 15:04:05"),
			MediaURL:     newFile.MediaURL,
			FileType:     newFile.FileType,
		}

		return newGroupFile, r.DB.Save(&newGroupFile).Error
	}
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	var files *model.GroupFiles

	if err := r.DB.First(&files, "id = ?", fileID).Error; err != nil {
		return false, err
	}

	return true, r.DB.Delete(&files).Error
}

// GetGroupFiles is the resolver for the getGroupFiles field.
func (r *queryResolver) GetGroupFiles(ctx context.Context, groupID string) ([]*model.FetchGroupFiles, error) {
	var files []*model.GroupFiles

	if err := r.DB.Where("group_id = ?", groupID).Find(&files).Error; err != nil {
		return nil, err
	}

	var fetchFilesGroups []*model.FetchGroupFiles

	for _, file := range files {
		fetchFile := &model.FetchGroupFiles{
			ID:           file.ID,
			GroupID:      file.GroupID,
			OwnerID:      file.OwnerID,
			FileName:     file.FileName,
			UploadedDate: file.UploadedDate,
			MediaURL:     file.MediaURL,
			OwnerData:    nil,
			FileType:     file.FileType,
		}
		// Retrieve user data based on AuthorID from the database
		var user model.User

		if err := r.DB.Where("id = ?", fetchFile.OwnerID).First(&user).Error; err != nil {
			return nil, err
		}

		fetchFile.OwnerData = &user

		fetchFilesGroups = append(fetchFilesGroups, fetchFile)
	}

	return fetchFilesGroups, nil
}

// GetFileByName is the resolver for the getFileByName field.
func (r *queryResolver) GetFileByName(ctx context.Context, fileName string) (*model.GroupFiles, error) {
	var file *model.GroupFiles

	err := r.DB.Where("file_name = ?", fileName).First(&file).Error

	if err != nil {
		return nil, err
	}

	return file, nil
}

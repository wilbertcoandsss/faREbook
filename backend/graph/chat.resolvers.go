package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/wilbertcoandssss/training-preweb/graph/model"
)

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, inputChatHeader model.NewChatHeader) (bool, error) {
	newChat := &model.ChatHeader{
		ID:        uuid.NewString(),
		UserID1:   inputChatHeader.UserID1,
		UserID2:   inputChatHeader.UserID2,
		CreatedAt: time.Now().Format("2006-01-02 15:04:05"),
	}

	return true, r.DB.Save(&newChat).Error
}

// CreateMessage is the resolver for the createMessage field.
func (r *mutationResolver) CreateMessage(ctx context.Context, inputChatDetail model.NewChatDetail) (bool, error) {
	if inputChatDetail.Type == "Text" {
		newMsg := &model.ChatDetails{
			ID:           uuid.NewString(),
			ChatHeaderID: inputChatDetail.ChatHeaderID,
			SenderID:     inputChatDetail.SenderID,
			ChatText:     inputChatDetail.ChatText,
			CreatedAt:    time.Now().Format("2006-01-02 15:04:05"),
			Type:         "Text",
			MediaURL:     "",
		}

		for _, conn := range r.Conns {
			err := conn.WriteJSON(&newMsg)
			if err != nil {
				fmt.Println("kenapa errornya", err)
			}
		}

		return true, r.DB.Save(&newMsg).Error
	} else if inputChatDetail.Type == "Post" {
		newMsg := &model.ChatDetails{
			ID:           uuid.NewString(),
			ChatHeaderID: inputChatDetail.ChatHeaderID,
			SenderID:     inputChatDetail.SenderID,
			ChatText:     inputChatDetail.ChatText,
			CreatedAt:    time.Now().Format("2006-01-02 15:04:05"),
			Type:         "Post",
			MediaURL:     inputChatDetail.MediaURL,
		}

		for _, conn := range r.Conns {
			err := conn.WriteJSON(&newMsg)
			if err != nil {
				fmt.Println("yg post kenapa", err)
			}
		}

		return true, r.DB.Save(&newMsg).Error
	} else {
		newMsg := &model.ChatDetails{
			ID:           uuid.NewString(),
			ChatHeaderID: inputChatDetail.ChatHeaderID,
			SenderID:     inputChatDetail.SenderID,
			ChatText:     inputChatDetail.ChatText,
			CreatedAt:    time.Now().Format("2006-01-02 15:	"),
			Type:         "Media",
			MediaURL:     inputChatDetail.MediaURL,
		}

		for _, conn := range r.Conns {
			err := conn.WriteJSON(&newMsg)
			if err != nil {
				fmt.Println(err)
			}
		}

		return true, r.DB.Save(&newMsg).Error
	}
}

// CreateInstantChat is the resolver for the createInstantChat field.
func (r *mutationResolver) CreateInstantChat(ctx context.Context, inputChatHeader model.NewChatHeader) (*model.ChatHeader, error) {
	newHeader := &model.ChatHeader{
		ID:        uuid.NewString(),
		UserID1:   inputChatHeader.UserID1,
		UserID2:   inputChatHeader.UserID2,
		CreatedAt: time.Now().Format("2006-01-02 15:04:05"),
	}

	for _, conn := range r.Conns {
		err := conn.WriteJSON(&newHeader)
		if err != nil {
			fmt.Println(err)
		}
	}

	return newHeader, r.DB.Save(&newHeader).Error
}

// GetChatHeader is the resolver for the getChatHeader field.
func (r *queryResolver) GetChatHeader(ctx context.Context, userID1 string, userID2 string) (string, error) {
	var chatHeader *model.ChatHeader

	if err := r.DB.
		Where("(user_id1 = ? AND user_id2 = ?) OR (user_id2 = ? AND user_id = ?)", userID1, userID2, userID2, userID1).
		First(&chatHeader).Error; err != nil {
		return "", nil
	}

	return chatHeader.ID, nil
}

// GetAllConversation is the resolver for the getAllConversation field.
func (r *queryResolver) GetAllConversation(ctx context.Context, userID string) ([]*model.FetchChat, error) {
	var convos []*model.ChatHeader

	if err := r.DB.Where("user_id1 = ? OR user_id2 = ?", userID, userID).Find(&convos).Error; err != nil {
		return nil, err
	}

	var fetchConvos []*model.FetchChat

	for _, convo := range convos {
		fetchConvo := &model.FetchChat{
			ChatHeaderID:           convo.ID,
			ChatHeaderInformation:  nil,
			ChatDetailsInformation: nil,
			ReceiverID:             "",
			UserID1Data:            nil,
			UserID2Data:            nil,
			PostData:               nil,
			PostAuthor:             nil,
		}

		var user1 model.User

		if err := r.DB.Where("id = ?", convo.UserID1).First(&user1).Error; err != nil {
			return nil, err
		}

		fetchConvo.UserID1Data = &user1

		var user2 model.User

		if err := r.DB.Where("id = ?", convo.UserID2).First(&user2).Error; err != nil {
			return nil, err
		}

		fetchConvo.UserID2Data = &user2

		var chatHeaderInfo model.ChatHeader

		if err := r.DB.Where("id = ?", convo.ID).First(&chatHeaderInfo).Error; err != nil {
			return nil, err
		}

		fetchConvo.ChatHeaderInformation = &chatHeaderInfo

		var chatDetails []*model.ChatDetails
		if err := r.DB.Where("chat_header_id = ?", convo.ID).Find(&chatDetails).Error; err != nil {
			return nil, err
		}

		fetchConvo.ChatDetailsInformation = chatDetails

		var postData []*model.Post
		var postAuthor []*model.User

		for _, chatDetail := range chatDetails {
			_, err := uuid.Parse(chatDetail.MediaURL)
			if err == nil {
				var p *model.Post

				if err := r.DB.Where("id = ?", chatDetail.MediaURL).First(&p).Error; err != nil {
					return nil, err
				}

				var u *model.User

				if err := r.DB.Where("id = ?", p.AuthorID).First(&u).Error; err != nil {
					return nil, err
				}
				fmt.Println("MediaURL is a valid UUID:", chatDetail.MediaURL)

				fmt.Println(p.ContentText, u.Firstname)

				postData = append(postData, p)
				postAuthor = append(postAuthor, u)

			} else {
				fmt.Println("MediaURL is not a valid UUID:", chatDetail.MediaURL)
			}

		}

		fetchConvo.PostData = postData
		fetchConvo.PostAuthor = postAuthor

		fetchConvos = append(fetchConvos, fetchConvo)
	}

	return fetchConvos, nil
}
